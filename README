# تمرین اول

*امیر معینی، سارا آذرنوش*

# پرسش‌ها

۱. 
این پوشه عملا 
working directory
نرم‌افزار 
git
است. 
این پوشه شامل تمام اطلاعات مربوط به 
version control
پروژه مانند فایل‌های 
object 
(که شامل کامیت‌ها، فایل‌های موجود در پروژه و همچنین ساختار پوشه‌هاست)،
فایل‌های 
ref
(برای نگهداری برنچ‌ها، تگ‌ها و ...)
، فایل‌ کانفیگ و ... است.
با زدن دستور 
`git init`
فولدری که در آن هستیم آماده‌ی version control می‌شود 
و متعاقبا این پوشه نیز ایجاد می‌شود.

۲.
یعنی اینکه هر 
commit
یا 
pull request
مربوط به دقیقا یک تغییر معنادار که می‌توان آن را در یک جمله توصیف کرد باشد نه اینکه چندین کار را با هم انجام دهد یا اینکه اصلا بدون 
commitهای
بعدش بی‌معنی باشد و هیچ تغییر معناداری در پروژه ایجاد نکرده باشد.

۳.
دستور
`git fetch`
صرفا از اطلاعات لوکال راجع به ریموت را آپدیت می‌کند. این اطلاعات شامل کامیت‌ها و وضعیت برنچ‌هاست. ولی `git pull` علاوه بر
همین‌کار، عملیات ادغام شاخه‌ی لوکال کنونی با شاخه‌ی متناظرش در ریموت را نیز انجام می‌دهد. این ادغام می‌تواند توسط rebase
یا 
merge باشد.
در merge تغییرات شاخه‌ی دیگری در طی یک کامیت در شاخه‌ی کنونی، به این شاخه اضافه می‌شوند. اما در rebase
تک تک کامیت‌های برنچ دیگری، بعد از آخرین نقطه مشترک آن برنچ با برنچ کنونی، در برنچ کنونی قرار می‌گیرند(و ممکن است به ازای هر کدام از آنها مجبور به حل کردن conflict شویم!)، یعنی عملا پایه‌ی آن برنچ، به آخرین کامیت برنچ کنونی تغییر میکند.

۴. در این بین، revert
متفاوت‌ترین است و عملا کامیتی ایجاد می‌کند که هدف آن بازگردانی تغییراتی است که یک کامیت خاص به وجود آورده است. restore با کانفیگ‌های مختلف می‌تواند کد یک کامیت را بردارد و در stage بگذارد یا اینکه حتی آن را در working directory بگذارد. شبیه این کار را 
`git reset --mixed` و 
`git reset --hard`
نیز انجام می‌دهند. ولی نکته‌ای که وجود دارد این است که دستور `reset`
 می‌تواند ‍‍ref یک برنچ را به کامیت‌های قبل‌تر ببرد، این کار را restore نمی‌تواند انجام دهد.
